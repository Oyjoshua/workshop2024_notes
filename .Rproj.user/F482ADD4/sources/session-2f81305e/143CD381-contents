### Subsetting and processing data by groups

 ## plyr and dplyr are popular packages for manipulating data in R
  # We will not use these in class, so this is just an FYI
  # https://cran.r-project.org/web/packages/dplyr/
  # https://cran.r-project.org/web/packages/plyr/
  
options(digits = 4)

# set.seed() function sets the starting value used to generate random numbers. This ensures
# the same result if the same seed is used to run the same process ; can be any value

set.seed(5)
              
# create a small data frame with four variables, then print to console

data <- data.frame(var1 = rnorm(8, 25, 5),
                   var2 = rnorm(8, 35, 6),
                   var3 = rpois(8, 10),
                   group = c("A", "A", "A", "B", "B", "B", "C", "C"))
data


### ---- Subsetting observations (rows) based on values of variables with the subset() function

subset(data, group == 'A')   # reminder == is the 'equal to' operator

# reminder: to save a subset for later use, assign the output to an object

groupA <- subset(data, group == 'A')

# | (pipe) is the Boolean OR operator (select observations that meet ANY of the specified conditions)

subset(data, group == 'B' | group == 'C')

# & is the Boolean AND operator (select observations that meet ALL of the specified conditions)

subset(data, group == 'C' & var3 > 10)


### which() using indexes [] to create the same subset as above

data[which(data$group == 'C' & data$var3 > 10), ]


###  ---- Processing data by group

# aggregate() function is one way; it requires three arguments:
  # input data (data =)
  # grouping variable(s) (~ or by = list())
  # function to apply to each group (FUN =)

# example: compute the mean by group for one variable in a data frame

aggregate(data$var1 ~ group, data = data, FUN = mean)  # tilde identifies grouping var

# same result but using list() to indicate the grouping variable(s)
  # note different output format when using a list

aggregate(data$var1, by = list(data$group), FUN = mean)

# FUN = can be most any numeric R function, such as sum, var, sd, length, median, etc.
#  and several can be evaluated simultaneously using function() and c()
#  note, the 'x' in function(x) is just a placeholder

aggregate(data$var1 ~ data$group, 
  FUN = function(x) c(n = length(x), mean = mean(x), sd = sd(x)))

# computing the mean by group for multiple variables at once requires that we assemble columns

 # option 1. join columns with cbind() -- the column bind function
   cbind(data$var1, data$var2)         # illustrates output of cbind() 
   
   aggregate(cbind(data$var1, data$var2) ~ data$group, FUN = mean)

 # option 2. identify variables using data.frame indexing [] and variable names 
   aggregate(data[ , c('var1','var2')], by = list(data$group), FUN = mean)

   # with indexing, the ~ form doesn't work, so use a list()
   # aggregate(data[ , c('var1','var2')] ~ data$group, FUN = mean)  # throws an error
 
 # option 3. apply FUN to all columns with '.'
   aggregate(. ~ group, data = data, FUN = mean)

 # option 4. use colnames() to include all columns and the != operator (not equal to) 
 # to exclude the non-numeric columns
   aggregate(data[ , colnames(data) != "group"], by = list(data$group), FUN = mean)

# Two additional functions for processing groups: by() and apply()

by(data$var1, data$group, function(x) mean(x))
tapply(data$var1, data$group, mean)
